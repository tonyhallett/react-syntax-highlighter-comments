"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var Typography_1 = __importDefault(require("@material-ui/core/Typography"));
var common_1 = require("../common");
var demoCommentReactIcon_1 = require("./examples/demoCommentReactIcon");
function getInitialCode() {
    return "\n/*\n  \n  Below are built-in components that work with the commentTagInterceptor.\n  \n  All builtin components respect the respectStyleProp property apart from CommentStyle \n  which always respects and StyleColor that never respects and just takes the color css property from the \n  style prop comment key.\n\n  You can also attach styleProps property to your component\n  CommentLink has displayProps = 'link'  and wll receive linkStyleProp.\n\n  \n  CommentReactIcon will render the react icon.  \n  \n  $ StyledComment can render a styled multiline $ $ comment #red$ \n  (comment prop string []) or styled single line $ comment #red$ \n  (comment prop string) or child.\n  For single line - position with spaces.  For multiline you will need the tab property.\n  $ RedComment renders a red $ $ StyledComment. #red$\n  $ MultiComment will render the $ $ comment chars #red$ and render children on new lines ( divs).  \n  It too has the tab property.\n  $ Comment will render $ $ chars // #red $ and render the children elements. \n  StyleColour will render a span styled with the colour from the style prop comment key, if present.\n  Coloured renders a span with colour.  There is a component for each css color name - see Skyblue below\n  There are components for the fontStyle, fontWeight and fontSize.  There are also many text decoration components \n  that cover all permutations of textDecorationLine, textDecorationStyle and textDecorationColor from the css color names.  \n  There is a common naming to these.  For instance the name UlOlLtWavyLimegreen is composed of \n  3 parts the textDecorationLine, textDecorationStyle and then the textDecorationColor.\n  UlOlLt means all 3 line decorations.\n  Wavy is the style ( if Solid then exclude this part).\n  Limegreen is the color used and can be excluded.\n  Thus the most minimal is Ul, Ol and Lt.\n  For full control there is the TextDecoration component where you can also specify the color to be used.\n  The fontStyle, fontWeight, fontSize and textDecoration can all wrap other components.\n  \n  CommentLink will render a link with full props and styling, it will merge in style from style prop link according to respectStyleProp.\n  \n  CommentPlaceholder will render it's children.  Its purpose is to hide children from normal render and only \n  render from within react-syntax-highlighter.\n  \n  \n*/\n<StyledComment style={{color:'white',backgroundColor:'red'}}>React Icon</StyledComment>\n<CommentReactIcon/>\nfunction commentViaTag(){\n  <RedComment>this line is important </RedComment><CommentLink linkProps={{href:'https://www.merriam-webster.com/dictionary/important', target:'_blank',style:{color:'hotpink'}}}>for more info</CommentLink>\n  const important='very';\n  <StyledComment tab={2} comment={['multiline and', 'styled','tab=2']} style={{color:'white',backgroundColor:'red'}}/>\n  return important;\n}\n    \n<Comment><Red>This is important</Red><CommentStyle> but this is not</CommentStyle><Orange> and this is orange.</Orange></Comment>\n<Comment><CommentStyle>This always uses the style prop ( regardless of respectStyleProp )</CommentStyle><StyleColour> and this never uses it.</StyleColour></Comment>\n\n// in addition to <> it recognises React.Fragment or Fragment\n<MultiComment>\n  <>\n    <Coloured color='#d10a14'>A Red comment </Coloured>\n    <Coloured color='#5b2eff'>A Blue comment </Coloured>\n    <Skyblue>Sky blue </Skyblue>\n    \n  </>\n  <Coloured color='#2effc4'>A Green comment</Coloured>\n\n  <Italic>Italic</Italic>\n  <Lighter>Lighter</Lighter>\n  <Bold>Bold</Bold>\n  <Bolder>Bolder</Bolder>\n  <Bold><Italic><Red>Bold and Italic and red</Red></Italic></Bold>\n  <Red><Italic>Italic</Italic><XLarge> and X Large</XLarge></Red>\n  <XXSmall>XXSmall</XXSmall>\n  <XSmall>XSmall</XSmall>\n  <Small>Small</Small>\n  <Medium>Medium</Medium>\n  <Large>Large</Large>\n  <XLarge>X Large</XLarge>\n  <XXLarge>XX Large</XXLarge>\n  <XXXLarge>XXX Large</XXXLarge>\n  <Smaller>Smaller</Smaller>\n  <Larger>Larger</Larger>\n  <UlOlLtWavyLimegreen>All lines wavy and lime green !</UlOlLtWavyLimegreen>\n  <TextDecoration l='ulol' c='#FF4666' s='wavy' th='10px'>Use this for full control</TextDecoration>\n</MultiComment>\n\n    <MultiComment tab={4}>\n      <>\n        <Indianred>Tab</Indianred>\n        <Hotpink>=</Hotpink>\n        <Gold>4</Gold>\n      </>\n      <Lime>Set tab to match leading space</Lime>\n    </MultiComment>\n\n\n<span>This is not processed</span>\n<CommentPlaceholder><span>But this is</span></CommentPlaceholder>\n<Span style={{background:'green'}}>Style prop aware span</Span>\n<Div style={{background:'blue'}}>Style prop aware div</Div>\n\n\n<AdditionalProps style={{color:'red',backgroundColor:'white'}}>Styled based upon mergeObjectProps and propsPrecedence.</AdditionalProps>\n";
}
;
function Introduction() {
    return React.createElement(common_1.Expandable, { header: 'Introduction' },
        React.createElement(Typography_1.default, null, "The comment tag interceptor is available in Prism only as Light does not support the languages jsx and tsx."),
        React.createElement(Typography_1.default, { gutterBottom: true }, "This interceptor is different to all of the others as it works with actual React components and not special syntax embedded in to comments. When a tag is encountered the component provider is asked for the corresponding react component type to be rendered. By designing your components in a particular way you can embed a React component in your code that will only be rendered when used within react-syntax-highlighter when used with the comment tag interceptor or the SyntaxHighlighterComments component."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "CommentDisplay prop"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "The comment tag interceptor adds additional properties to the components that it creates.  One of these is the commentDisplay prop which is set to true.  By designing components that render only when commentDisplay is true your components will only be viewable within the react-syntax-highlighter when used with the comment tag interceptor or the SyntaxHighlighterComments component."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Styling - respectStyleProp and commentStyleProp"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "The comment tag interceptor, like all interceptors, has access to the react-syntax-highlighter style prop.  It provides the comment key value from this as the commentStyleProp.  Your component can choose to use it as part of its own styling.  The respectStyleProp is an indicator to the component whether it should if it makes sense to do so.  The respectStyleProp comes from the globalRespectStyleProp argument of the comment tag interceptor which defaults to true, or can come from the ComponentProvider and be set on a component type basis."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Other style keys"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "If your component type has a styleProps property of type string or string array then it will received additional props with values from the react-syntax-highlighter style prop in a similar manner to the comment prop.  If styleProps is link then your component will receive a linkStyleProp."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Additional props for all instances"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "The ComponentProvider, in addition to returning the component type, can provide additional props for those tags encountered in the code string.  The additionalProps property is also where you set the respectStyleProp for a particular component type."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Precedence and object merging"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "How these additional props appear on an instance is determined by the propsPrecedence and mergeObjectProps properties.  By default precedence is Instance and mergeObjectProps is true.  This will result in any props on the Instance taking precedence over the addition props. Non object props in additionalProps will be ignored and for object props they are merged in.  Where properties exist on the instance object and the object from the additonalProps, again the instance property will take precedence.  With merging you can supply some additional styling in the CommentProvider."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Built in components"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "There are built in style prop aware components that can be used.  There are components for single line and multiline comments, components for colours and general styling, a link component, a React icon and components for font styling.  There is a placeholder component for managing commentDisplay and you can render html elements as children.  Although if you do that you lose access to the react-syntax-highlighter style prop.  Due to this there are style prop aware versions of all the html element tags."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "builtInComponentProvider / builtInComponentFinder"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "You can import the components that are in the code string and return them in the ComponentProvider ( use the displayName for matching aginst the tagName) or you can you use the builtInComponentProvider which imports all components and returns the component with displayName equal to the tagName. If you are supply additional props then you can use the builtInCoponentFinder to return the component type."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Limitations"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "If the code string is generated from actual code then there are limitations to where a tag can appear.  A tag cannot be used alongside a parameter nor inside a class where a class member is expected.  A possible solutionto this is fake decorators...."),
        React.createElement(Typography_1.default, { variant: "h4", gutterBottom: true }, "Examples"),
        React.createElement(Typography_1.default, { gutterBottom: true }, "Examples follow the API to illustrate the concepts and the built in components."));
}
function CommentTagInterceptorApi() {
    var api = "\n  export interface RespectStyleProp{\n    respectStyleProp?:boolean // on a type basis.  Overrides globalRespectStyleProp\n  }\n  export type\u00A0AdditionalProps\u00A0=\u00A0RespectStyleProp & Record<string,any>\n\n  export enum PropsPrecedence { Instance /* default */, AdditionalProps}\n  \n  export\u00A0interface\u00A0ComponentTypeWithProps\u00A0{\n    type:React.ComponentType,\n\n    /*\n      the resulting props on the instance ( props defined on the instance and additionalProps )\n      are determined by the propsPrecedence and mergeObjectProps\n    */\n    additionalProps:AdditionalProps, \n    propsPrecedence?:PropsPrecedence, // default Instance\n    mergeObjectProps?:boolean // default true\n  }\n\n  /*\n    if no additional props are to be added or respectStyleProp is not required\n    then just return the type to be rendered\n  */\n  export\u00A0type\u00A0ComponentTypeOrWithProps\u00A0=\u00A0React.ComponentType|ComponentTypeWithProps\n  \n  // return the type to be rendered ( see builtInComponentProvider for use with built in components)\n  export\u00A0interface\u00A0ComponentProvider{\n  \u00A0\u00A0(tagName:string):ComponentTypeOrWithProps|undefined;\n  }\n  \n  export const createCommentTagInterceptor = (componentProvider:ComponentProvider, globalRespectStyleProp=true):NodeRenderInterceptor\n  ";
    return React.createElement(common_1.InterceptorApi, null, api);
}
function CommentTagInterceptorComponentAPI() {
    var props = "\n  interface SyntaxHighlighterCommentsProps{\n    commentTagProvider?:ComponentProvider,\n    respectStyleProp?:boolean,// default true\n  }\n  ";
    return React.createElement(common_1.ComponentApi, null, props);
}
function Demos() {
    return React.createElement(common_1.Expandable, { header: 'Demos' },
        React.createElement(React.Fragment, null,
            React.createElement(BuiltInComponentsDemos, null)));
}
function BuiltInComponentsDemos() {
    return React.createElement(common_1.Expandable, { header: 'Built in components' },
        React.createElement(React.Fragment, null,
            React.createElement(common_1.Expandable, { header: 'CommentReactIcon' },
                React.createElement(demoCommentReactIcon_1.DemoCommentReactIcon, null))));
}
function DemoCommentTagInterceptor() {
    return React.createElement(React.Fragment, null,
        React.createElement(Introduction, null),
        React.createElement(CommentTagInterceptorApi, null),
        React.createElement(CommentTagInterceptorComponentAPI, null),
        React.createElement(Demos, null));
}
exports.DemoCommentTagInterceptor = DemoCommentTagInterceptor;
